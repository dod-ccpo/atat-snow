import "reflect-metadata";
import cors from "@middy/http-cors";
import jsonBodyParser from "@middy/http-json-body-parser";
import JSONErrorHandlerMiddleware from "middy-middleware-json-error-handler";
import middy from "@middy/core";
import validator from "@middy/validator";
import { ApiGatewayEventParsed } from "../utils/eventHandlingTool";
import { APIGatewayProxyResult, Context } from "aws-lambda";
import { ApiSuccessResponse, SuccessStatusCode } from "../utils/response";
import { CORS_CONFIGURATION } from "../utils/corsConfig";
import { createConnection } from "../utils/database";
import { errorHandlingMiddleware } from "../utils/errorHandlingMiddleware";
import { IpCheckerMiddleware } from "../utils/ipLogging";
import { IPortfolio, IPortfolioCreate } from "../../orm/entity/Portfolio";
import { PortfolioRepository } from "../repository/PortfolioRepository";
import { validateRequestShape } from "../utils/shapeValidator";
import { wrapSchema } from "../utils/schemaWrapper";
import schema = require("../models/internalSchema.json");
import xssSanitizer from "../utils/xssSanitizer";
import { EmptyPortfolioMiddleware } from "../utils/emptyPortfolioMiddleware";
import createError from "http-errors";

/**
 * Creates a new Portfolio
 * A new portfolioId will be generated by the database.
 *
 * @param event - The POST request from API Gateway
 */
export async function baseHandler(
  event: ApiGatewayEventParsed<IPortfolio>,
  context?: Context
): Promise<APIGatewayProxyResult> {
  const setupResult = validateRequestShape<IPortfolio>(event);
  const portfolioBody = setupResult.bodyObject;

  // set up database connection
  const connection = await createConnection();
  const portfolioRepository = connection.getCustomRepository(PortfolioRepository);
  let insertedPortfolio: IPortfolioCreate;

  try {
    // Business rule 1.1: unique Portfolio Name
    const existingPortfoliosWithIdenticalName = await portfolioRepository.getPortfoliosByName(portfolioBody.name);
    if (existingPortfoliosWithIdenticalName.length > 0) {
      throw createError(400, "Duplicate portfolio name", {
        errorName: "DuplicatePortfolioName",
        portfolioName: portfolioBody.name,
      });
    }

    const insertResult = await portfolioRepository.createPortfolio(portfolioBody);
    const portfolioId = insertResult.identifiers[0].id;
    // query for the newly inserted portfolio
    insertedPortfolio = await portfolioRepository.findOneOrFail({
      select: [
        "id",
        "name",
        "csp",
        "description",
        "dodComponents",
        "owner",
        "portfolioManagers",
        "createdAt",
        "updatedAt",
        "archivedAt",
        "administrators",
      ],
      where: { id: portfolioId },
    });

    console.log("Inserted Portfolio: " + JSON.stringify(insertedPortfolio));
  } finally {
    connection.close();
  }

  return new ApiSuccessResponse<IPortfolioCreate>(insertedPortfolio, SuccessStatusCode.CREATED);
}

// a workaround for ensuring validation does not give a false failure due to 'allOf'
// also a band-aid for ensuring BaseObject properties (e.g., id) are not accepted
// when sent in the request body
const { type, additionalProperties, required: portfolioRequired } = schema.Portfolio;
const { required: baseRequired } = schema.PortfolioBase;
const { portfolioManagers, description, owner /*, applications */ } = schema.Portfolio.properties;
const { csp, dodComponents, name } = schema.PortfolioBase.properties;
const { administrators } = schema.PortfolioAccess.properties;
const portfolioSchema = {
  type,
  additionalProperties,
  required: baseRequired.concat(portfolioRequired),
  properties: {
    portfolioManagers,
    description,
    owner,
    // applications,
    csp,
    dodComponents,
    name,
    administrators,
  },
};

export const handler = middy(baseHandler)
  .use(IpCheckerMiddleware())
  .use(xssSanitizer())
  .use(jsonBodyParser())
  .use(EmptyPortfolioMiddleware())
  .use(validator({ inputSchema: wrapSchema(portfolioSchema) }))
  .use(errorHandlingMiddleware())
  .use(JSONErrorHandlerMiddleware())
  .use(cors(CORS_CONFIGURATION));
