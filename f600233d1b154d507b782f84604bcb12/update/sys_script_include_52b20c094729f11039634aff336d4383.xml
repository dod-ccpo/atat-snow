<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_g_dis_atat.GetPortfolioDetails</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>GetPortfolioDetails</name>
        <script><![CDATA[var GetPortfolioDetails = Class.create();
GetPortfolioDetails.prototype = {
    errUtil: new ErrorHandler(),
    portfolioId: null,
    userId: null,
    portfolio: new GlideRecord('x_g_dis_atat_portfolio'),
    taskOrder: new GlideRecord('x_g_dis_atat_task_order'),
    clinsGR: new GlideRecord('x_g_dis_atat_clin'),
    CLINS_TABLE: 'x_g_dis_atat_clin',
    ENVIRONMENT_TABLE: 'x_g_dis_atat_environment',
    COST_TABLE: 'x_g_dis_atat_costs',

    ctb: this.convertToBoolean,

    initialize: function(portfolioId, userId) {
        this.portfolioId = portfolioId;
        this.userId = userId;
    },

    availableFunds: function() {
        // available_funds = total_funds (value of all exercised CLINs) minus funds_spent (total of all actual costs to date).

        const total_funds = parseFloat(new global.GlideQuery(this.CLINS_TABLE)
            .where('task_order', this.taskOrder.sys_id)
            .where(new global.GlideQuery()
                .where('clin_status', '!=', 'EXPIRED'))
            .sum('funds_total')
            .orElse(0.0));

        const funds_spent = this.totalFundsSpent();
        const available_funds = total_funds - funds_spent;
        gs.info(`
		Task Order ID: ${this.taskOrder.sys_id} 
		Calculation: Funds Spent
	    + ${total_funds} (Total Funds)
		- ${funds_spent} (Funds Spent)
		= ${available_funds} (Available Funds)
		`);
        return available_funds;
    },

    taskOrderHelper: function() {
        const data = {
            task_order_id: this.taskOrder.sys_id,
            task_order_status: this.taskOrder.task_order_status,
            estimated_funds_available: this.estimatedFundsAvailable(),
            total_task_order_value: this.totalTaskOrderValue(),
            total_lifecycle_amount: this.totalTaskOrderLifecycleAmount(),
            total_funds_spent: this.totalFundsSpent(),
            total_obligated_funds: this.totalObligatedFunds()
        };

        return data;
    },

    estimatedFundsAvailable: function() {
        // total funds - funds spent - estimated_funds_to_be_invoiced (month only)
        // if have costs with projected spend (is_actual === false), sum of all projected. 
        // Else, just return monthly average

        let total_obligated_funds = this.totalTaskOrderValue();
        let total_funds_spent = this.totalFundsSpent();

        // get projected spend for month

        let estimated_funds_to_be_invoiced = parseFloat(new global.GlideQuery(this.COST_TABLE)
            .where('portfolio', this.portfolioId)
            .where('is_actual', false)
            .sum('value')
            .orElse(0.0));

        // if no projected spend, calculate monthly avg
        // TODO; talk to Jeff/Koko ?
        if (estimated_funds_to_be_invoiced === 0.0) {
            gs.info(`Projected Spend === 0.0; calculating monthly avg (placeholder).`);
            estimated_funds_to_be_invoiced = 10000.00;
        }

        const estimated_funds_available = total_obligated_funds - total_funds_spent - estimated_funds_to_be_invoiced;

        gs.info(`
		Task Order ID: ${this.taskOrder.sys_id} 
		Calculation: Estimated Funds Available
	    + ${total_obligated_funds} (Total Obligated Funds)
		- ${total_funds_spent} (Total Funds Spent)
		- ${estimated_funds_to_be_invoiced} (Estimated Funds To Be Invoiced)
		= ${estimated_funds_available} (Estimated Funds Available)
		`);
        return estimated_funds_available;
    },

    totalTaskOrderLifecycleAmount: function() {
        // sum of all funds_total values for all CLINs in all periods, past, present and future

        let total_lifecycle_amount = parseFloat(new global.GlideQuery(this.CLINS_TABLE)
            .where('task_order', this.taskOrder.sys_id)
            .sum('funds_total')
            .orElse(0.0));

        gs.info(`
		totalTaskOrderLifecycleAmount
		Task Order ID: ${this.taskOrder.sys_id} 
		Calculated: ${total_lifecycle_amount}
		`);
        return total_lifecycle_amount;
    },

    totalTaskOrderValue: function() {
        // sum of all funds_total values for all CLINs (excercised) in all periods, past, present and future
        // exercised -> all clins with funds obligated?

        let total_task_order_value = parseFloat(new global.GlideQuery(this.CLINS_TABLE)
            .where('task_order', this.taskOrder.sys_id)
            .where('funds_obligated', '>', 0.0)
            .sum('funds_total')
            .orElse(0.0));

        gs.info(`
		totalTaskOrderValue
		Task Order ID: ${this.taskOrder.sys_id} 
		Calculated: ${total_task_order_value}
		`);
        return total_task_order_value;
    },

    totalFundsSpent: function() {
        // sum of all current and past clins actual_funds_spent ==> CLINS table key
        let total_funds_spent = parseFloat(new global.GlideQuery(this.COST_TABLE)
            .where('portfolio', this.portfolioId)
            .sum('value')
            .orElse(0.0));

        gs.info(`
		totalFundsSpent
		Task Order ID: ${this.taskOrder.sys_id} 
		Calculated: ${total_funds_spent}
		`);

        return total_funds_spent;
    },

    totalObligatedFunds: function() {
        let total_obligated_funds = new global.GlideQuery(this.CLINS_TABLE)
            .where('task_order', this.taskOrder.sys_id)
            .sum('funds_obligated')
            .orElse(0.0);
        gs.info(`
		totalObligatedFunds
		Task Order ID: ${this.taskOrder.sys_id} 
		Calculated: ${total_obligated_funds}
		`);
        return total_obligated_funds;
    },

    /**
     * Gets list of environments and its details for a given portfolio
     * @param {id} representing a portfolio sys_id
     * @return [Environment]  
     */
    getEnvironments: function() {
        const gr = new GlideRecord(this.ENVIRONMENT_TABLE);
        gr.addQuery('portfolio', this.portfolioId);
        gr.query();
        let environments = [];
        while (gr.next()) {
            environments.push({
                classification_level: gr.getValue('classification_level'),
                environment_status: gr.getValue('environment_status'),
                provisioning_request_date: gr.getValue('provisioning_request_date'),
                provisioned_date: gr.getValue('provisioned_date'),
                dashboard_link: gs.getProperty('glide.servlet.uri') + gr.getLink(false),
            });
        }
        return environments;
    },

    //TODO leverage getCostData() if at all possible
    /**
     * Gets costs for a given CLIN given the sys_id
     * @param {id}
     * @return {[{is_actual,value,year_month}]}
     */
    getCosts: function(id) {

        return ''; //data array json objects
    },
    /**
     * Parses CLIN details for a single clin given a CLIN record
     * @param {id} representing a CLIN sys_id
     * @return {clin_number,idiq_clin,active,clin_status,classification_level,funds_obligated,funds_total,pop_start_date,pop_end_date,type,costs}
     */
    getClinDetails: function(id) {
        //TODO get costs associated with each CLIN
        var clin = new GlideRecord(this.CLINS_TABLE);
        clin.get(id);
        return {
            clin_number: clin.clin_number,
            idiq_clin: clin.idiq_clin,
            active: Boolean(clin.active),
            actual_funds_spent: clin.actual_funds_spent,
            clin_status: clin.clin_status,
            classification_level: clin.classification_level,
            funds_obligated: clin.funds_obligated,
            funds_total: clin.funds_total,
            pop_start_date: clin.pop_start_date,
            pop_end_date: clin.pop_end_date,
            type: clin.type,
            costs: this.getCosts(clin.sys_id)
        };
    },
    /**
     * Gets CLINs for a given task order
     * @return data array of all CLINs for a task order
     */
    getClins: function() {
        var data = [];
        var clins = new GlideRecord(this.CLINS_TABLE);
        clins.addQuery('task_order', this.taskOrder.sys_id);
        clins.query();
        while (clins.next()) {
            var tmp = this.getClinDetails(clins.sys_id);
            data.push(tmp);
        }
        return data;
    },
    /**
     * Gets info for a single user record in the sys_user table
     * @param {id} representing a user sys_id 
     * @returns 
     */
    getUserInfo: function(id) {
        var user = new GlideRecord('sys_user');
        user.get(id);
        return {
            name: user.name,
            first_name: user.first_name,
            last_name: user.last_name,
            user_name: '', //what is this?
            email: user.email,
            company: user.company.name, //ref
            mobile_phone: user.mobile_phone,
            phone: user.commercial_phone,
            home_phone: user.home_phone,
            title: user.title
        };
    },
    getUserList: function(userString) {
        if (userString == '') {
            return '';
        }
        var data = [];
        if (userString.indexOf(',') === -1) {
            data.push(this.getUserInfo(userString.toString().trim()));
        } else {
            var usersList = userString.split(',');
            for (var i = 0; i < usersList.length; i++) {
                var userId = usersList[i].trim();
                data.push(this.getUserInfo(userId));
            }
        }
        return data;
    },
    /**
     * Gather ALL Cost data for a given Portfolio where task_order_number = portfolio.active_task_order
     * @param {toId} task_order_id used to filter costs table data
     * @return {[{agency,clin,csp,is_actual,organization,portfolio,task_order_number,value,year_month}]} for all cost records of the given task order
     */
    getCostData: function(toId) {
        const gr = new GlideRecord(this.COST_TABLE);
        var fundsObligated = 0.00;
        var fundsSpent = 0.00;
        var data = [];

        gr.addQuery('task_order_number', toId);
        gr.query();

        while (gr.next()) {
            var date = new GlideDateTime(gr.year_month);
            var tmp = {
                agency: gr.agency.getDisplayValue().toString(),
                clin: gr.clin.getDisplayValue().toString(),
                csp: gr.csp.getDisplayValue().toString(),
                is_actual: Boolean(gr.is_actual),
                organization: gr.organization.getDisplayValue().toString(),
                portfolio: gr.portfolio.getDisplayValue().toString(),
                taskOrderNumber: gr.task_order_number.getDisplayValue().toString(),
                value: gr.value != 0 ? parseFloat(gr.value) : 0,
                yearMonth: gr.year_month.getDisplayValue().toString(),
                year: date.getYearLocalTime(),
                month: date.getMonthLocalTime(),
                day: date.getDayOfMonthLocalTime(),
            };
            data.push(tmp);
        }
        return data;
    },
    getDetails: function() {
        this.portfolio.get(this.portfolioId);
        this.taskOrder.get(this.portfolio.active_task_order);
        const clins = this.getClins();
        const costData = this.getCostData(this.taskOrder.task_order_number);

        return {
            portfolio_name: this.portfolio.name,
            portfolio_status: this.portfolio.portfolio_status.toString(),
            agency: this.portfolio.agency.title.toString(),
            last_modified: this.portfolio.last_updated.toString(),
            current_user_is_owner: this.portfolio.portfolio_owner.toString() === this.userId ? true : false,
            current_user_is_manager: JSON.stringify(this.portfolio.portfolio_managers.toString()).includes(this.userId) ? true : false,
            vendor: this.portfolio.vendor.toString(),
            pop_start_date: this.taskOrder.pop_start_date,
            pop_end_date: this.taskOrder.pop_end_date,
            description: this.portfolio.description.toString(),
            is_archived: Boolean(this.portfolio.is_archived),
            last_updated: this.portfolio.last_updated,
            last_cost_data_sync: this.portfolio.last_cost_data_sync,
            funding_status: this.portfolio.portfolio_funding_status,

            portfolio_users: {
                creator: this.portfolio.sys_created_by,
                owner: this.getUserInfo(this.portfolio.portfolio_owner),
                managers: this.getUserList(this.portfolio.portfolio_managers),
                viewers: this.getUserList(this.portfolio.portfolio_viewers),
            },
            //begin calculations on CLINS
            total_obligated: '', //clinData.fundsObligated,
            funds_spent: '', //clinData.fundsSpent, 
            available_funds: this.availableFunds(),
            total_portfolio_funds: 0.0,
            period_funds_spent: 0,
            spend_monthly_average: 0,
            spend_last_month: 0,
            spend_end_of_month_forecast: 0,
            spend_period_to_date: 0,
            spend_end_of_period_forecast: 0,
            estimated_funds_to_be_invoiced: 0,
            estimated_funds_available: 0,
            //end calculations on CLINS
            //begin task order
            task_order: this.taskOrderHelper(),
            environments: this.getEnvironments(this.portfolioId),
            clins: clins,
            clinData: costData //internal use, prefer GlideAggregate over heavy calculations
        };
    },
    type: 'GetPortfolioDetails'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>tom.arnold</sys_created_by>
        <sys_created_on>2023-09-26 00:36:32</sys_created_on>
        <sys_id>52b20c094729f11039634aff336d4383</sys_id>
        <sys_mod_count>108</sys_mod_count>
        <sys_name>GetPortfolioDetails</sys_name>
        <sys_package display_value="ATAT" source="x_g_dis_atat">f600233d1b154d507b782f84604bcb12</sys_package>
        <sys_policy/>
        <sys_scope display_value="ATAT">f600233d1b154d507b782f84604bcb12</sys_scope>
        <sys_update_name>sys_script_include_52b20c094729f11039634aff336d4383</sys_update_name>
        <sys_updated_by>stephen.hayes</sys_updated_by>
        <sys_updated_on>2023-09-27 15:08:18</sys_updated_on>
    </sys_script_include>
</record_update>
