<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_g_dis_atat.Igce</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>Igce</name>
        <script><![CDATA[var Igce = Class.create();
Igce.prototype = {
    IGCE_ESTIMATE_TABLE: "x_g_dis_atat_igce_estimate",
    IGCE_ESTIMATE_FIELDS: ["acquisition_package", "classification_instance", "classification_level", "contract_type", "cross_domain_solution",
        "dow_task_number", "environment_instance", "idiq_clin_type", "title", "unit", "unit_price", "unit_quantity", "description"],
    ENV_INST_TABLE: "x_g_dis_atat_environment_instance",
    CLASS_INST_TABLE: "x_g_dis_atat_classification_instance",
    CROSS_DOMAIN_SOLN_TABLE: "x_g_dis_atat_cross_domain_solution",
    SELECTED_PERIOD_FIELDS: ["need_for_entire_task_order_duration", "selected_periods"],
    CLASSIFICATION_LEVEL_TABLE: "x_g_dis_atat_classification_level",
    TRAVEL_REQ_TABLE: "x_g_dis_atat_travel_requirement",
    TRAVEL_REQ_FIELDS: ["selected_periods", "duration_in_days", "number_of_travelers", "trip_location", "number_of_trips"],
    REQ_COST_ESTIMATE_TABLE: "x_g_dis_atat_requirements_cost_estimate",
    REQ_COST_ESTIMATE_FIELDS: ["travel_option", "travel_estimated_values", "surge_requirement_capabilities",// y/n choice
        "surge_requirement_capacity",// int
        "how_est_dev_contracting_office_other_charges_fee", // choice y/n
        "how_est_dev_contracting_office_other_fee_percentage", // int
        "how_est_dev_prev_cost_estimate_comp_option", //MORE_THAN / LESS_THAN / SAME
        "how_est_dev_prev_cost_estimate_comp_percentage", // integer
        "how_est_dev_cost_estimate_description", // string 1000 chars
        "how_est_dev_tools_used", //String 100
        "how_est_dev_other_tools_used", //string 100
        "travel_option", //choice I want to apply the same price estimate to all performance fields -> SINGLE, I want to estimate a different price for the base and each option period -> MULTIPLE or null
        "travel_estimated_values" // String: Tony refactoring to sys_id: quantity on 1/13/2023


    ],
    TRAINING_ESTIMATE_TABLE: "x_g_dis_atat_training_estimate",
    TRAINING_ESTIMATE_FIELDS: ["acquisition_package",
        "subscription_type", //choice
        "training_estimated_values", //4000 string with periodsys_id: quantity
        "training_option", //choice SINGLE is for all option periods MULTIPLE is for different
        "training_unit", //PER_PERSON 	PER_CLASS ANNUAL_SUBSCRIPTION MONTHLY_SUBSCRIPTION
        "estimated_price_per_training_unit", //price
        "cloud_support_environment_instance" //sys_id reference to Cloud Support Environment Instance

    ],
    PERIOD_TABLE: "x_g_dis_atat_period",
    PERIOD_FIELDS: ["period_type", "period_unit", "period_unit_count", "option_order"],
    CLOUD_SUPPORT_ENV_INST_TABLE: "x_g_dis_atat_cloud_support_environment_instance",
    CLOUD_SUPPORT_ENV_INST_FIELDS: ["instance_name", // Name of Training
        "classification_level",
        "need_for_entire_task_order_duration", "selected_periods", // selected period fields
        "anticipated_need_or_usage", // string description field (probably not needed)
        "training_format", // CHOICE: ONSITE_INSTRUCTOR_CONUS, ONSITE_INSTRUCTOR_OCONUS, VIRTUAL_SELF_LED, NO_PREFERENCE
        "training_location", // string location
    ],
    acquisitionPackage: null,
    errUtil: new ErrorHandler(),

    initialize: function (acquisitionPackage) {
        this.acquisitionPackage = acquisitionPackage;
    },
    getEstimatedObligation: function (filterFn) {
        return this.getPayload().templatePayload.periodsEstimate.map(function (estimate) {
            return estimate.periodLineItems;
        }).reduce(function (pre, cur) {
            return pre.concat(cur);
        }).reduce(function (result, item) {
            return result + (item.monthlyPrice * item.monthsInPeriod);
        }, 0);
    },

    getEstimatedBaseYearObligation: function () {
        return this.getPayload().templatePayload.periodsEstimate.filter(function (estimate) {
            return estimate.period.periodType == "BASE";
        }).map(function (estimate) {
            return estimate.periodLineItems;
        }).reduce(function (pre, cur) {
            return pre.concat(cur);
        }).reduce(function (result, item) {
            return result + (item.monthlyPrice * item.monthsInPeriod);
        }, 0);
    },
    getPackagePeriods: function (base, options) {
        try {
            // This returns the periods in the IGCE schema for the Periods Estimate Object
            var mappedPeriods = [];
            if (base) {
                mappedPeriods.push({
                    "period": {
                        "periodType": base.period_type.toString(),
                        "periodUnitCount": base.period_unit_count.toString(),
                        "periodUnit": base.period_unit.toString(),
                        "optionOrder": base.option_order.toString()
                    },
                    "periodLineItems": [],
                });
            }
            if (options) {
                getListRecords(options,
                    ["period_type", "period_unit_count", "period_unit", "option_order"],
                    "x_g_dis_atat_period")
                    .forEach(function (period) {
                        mappedPeriods.push({
                            "period": {
                                "periodType": period.period_type.toString(),
                                "periodUnitCount": period.period_unit_count.toString(),
                                "periodUnit": period.period_unit.toString(),
                                "optionOrder": period.option_order.toString()
                            }, "periodLineItems": []
                        });
                    });
            }
            return mappedPeriods;
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> getPackagePeriods(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },

    getInstancePeriodInfo: function (instance) {
        //This function retrieves:
        // selected_periods
        // need_for_entire_task_order_duration
        // Appending it to the given Instance
        try {
            var selectedPeriodsFields = ["period_type", "option_order", "period_unit", "period_unit_count"];

            var entireDuration = convertToBoolean(instance.need_for_entire_task_order_duration.toString());
            instance.need_for_entire_task_order_duration = entireDuration;

            if (entireDuration) {
                instance.selected_periods = [];
            } else {
                var selectedPeriods = [];
                var retrieved_periods = getListRecords(instance.selected_periods.toString(), selectedPeriodsFields, "x_g_dis_atat_period").map(removeSysId);
                for (var i = 0; i < retrieved_periods.length; i++) {
                    var formatted_option_order;
                    if (retrieved_periods[i].option_order == null) {
                        formatted_option_order = "";
                    }
                    else {
                        formatted_option_order = retrieved_periods[i].option_order.toString();
                    }
                    selectedPeriods.push({
                        "periodType": retrieved_periods[i].period_type.toString(),
                        "periodUnitCount": retrieved_periods[i].period_unit_count.toString(),
                        "periodUnit": retrieved_periods[i].period_unit.toString(),
                        "optionOrder": formatted_option_order
                    });
                };
                instance.selected_periods = selectedPeriods;
            }
            return instance;
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> getInstancePeriodInfo(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },

    mapIgceToPeriodsEstimate: function (data_to_map, periods_estimate) {
        try {
            // For each item in IGCE estimates
            data_to_map.forEach(function (item) {
                // For each period in the selected_periods array the instance
                item.quantity_info_periods.forEach(function (period) {

                    // Map period_type and base_period of the periods_estimate array
                    var formattedPeriodOutput = periods_estimate.map(function (input) {
                        return input.period.periodType + input.period.optionOrder;
                    });

                    var indexOfCurrentPeriod = formattedPeriodOutput.indexOf(period.periodType + period.optionOrder);
                    if (period.quantity) {
                        formattedQuantity = parseInt(period.quantity);
                    }
                    else {
                        formattedQuantity = 0;
                    }

                    // Insert into periods_estimate, under the specified period and period_line_items 
                    periods_estimate[indexOfCurrentPeriod].periodLineItems.push({
                        "idiqClin": Igce.prototype.determineIdiqClin(item.classification_level, item.idiq_clin_type),
                        "contractType": item.contract_type,
                        "dowTaskNumber": "TBD",//item.dow_task_number,
                        "serviceTitle": item.title,
                        "itemDescription": item.description,
                        "unitPrice": item.unit_price,
                        "quantity": formattedQuantity,
                        "unit": period.periodUnit.toLowerCase(),
                    });
                });

            });
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> mapIgceToPeriodsEstimate(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },
    mapTravelToPeriodsEstimate: function (travel_data, periods_estimate) {
        try {
            var travel_description_array = [];
            // For each item in periods estimate
            periods_estimate.forEach(function (period_item) {

                var full_travel_description = "";
                var unitPrice;

                // Loop through travel data to get full_travel_description
                travel_data.forEach(function (travel_item) {
                    travel_item.instance_info.selected_periods.forEach(function (travel_period) {
                        if (travel_period.periodType === period_item.period.periodType && travel_period.optionOrder === period_item.period.optionOrder) {

                            full_travel_description += travel_item.travel_description;
                            unitPrice = travel_period.quantity // travel estimated values are mapped per period
                        }
                    });
                });
                if (full_travel_description != "") {
                    travel_description_array.push({
                        "periodType": period_item.period.periodType,
                        "periodUnitCount": period_item.period.periodUnitCount,
                        "periodUnit": period_item.period.periodUnit,
                        "optionOrder": period_item.period.optionOrder,
                        "fullTravelDescription": full_travel_description,
                        "unitPrice": unitPrice
                    });
                }

            });

            travel_description_array.forEach(function (item) {

                // Map period_type and base_period of the periods_estimate array
                var formattedPeriodOutput = periods_estimate.map(function (input) {
                    return input.period.periodType + input.period.optionOrder;
                });

                var indexOfCurrentPeriod = formattedPeriodOutput.indexOf(item.periodType + item.optionOrder);
                // Insert into periods_estimate, under the specified period and period_line_items 
                periods_estimate[indexOfCurrentPeriod].periodLineItems.push({
                    "idiqClin": "x007 Travel",
                    "contractType": "T&M",
                    "dowTaskNumber": "10f",
                    "serviceTitle": "Travel",
                    "itemDescription": item.fullTravelDescription,
                    "unitPrice": item.unitPrice,
                    "quantity": 1, //always 1
                    "unit": "period",
                });


            });
        } catch (error) {
            throw this.errUtil.createError(
                "Igce --> mapTravelToPeriodsEstimate(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },
    determineTrainingUnit: function (training_unit) {
        switch (training_unit) {
            case "PER_PERSON":
                return "people";
            case "PER_CLASS":
                return "sessions";
            case "MONTHLY_SUBSCRIPTION":
                return "months";
            default:
                return "";
        }
    },

    mapTrainingToPeriodsEstimate: function (training_data, periods_estimate) {
        try {
            // For each item in Training Data
            training_data.forEach(function (item) {
                if (!item.training_instance_info.need_for_entire_task_order_duration) {
                    if (item.training_unit === "ANNUAL_SUBSCRIPTION") {
                        // map to only the selected_periods
                        // For each period in the selected_periods array the instance
                        item.training_instance_info.selected_periods.forEach(function (period) {

                            // Map period_type and base_period of the periods_estimate array
                            var formattedPeriodOutput = periods_estimate.map(function (input) {
                                return input.period.periodType + input.period.optionOrder;
                            });

                            var indexOfCurrentPeriod = formattedPeriodOutput.indexOf(period.periodType + period.optionOrder);

                            // Insert into periods_estimate, under the specified period and period_line_items 
                            periods_estimate[indexOfCurrentPeriod].periodLineItems.push({
                                "idiqClin": Igce.prototype.determineIdiqClin(item.classification_info, "CLOUD_SUPPORT"),
                                "contractType": "TBD",
                                "dowTaskNumber": "TBD",
                                "serviceTitle": item.training_instance_info.instance_name,
                                "itemDescription": item.training_instance_info.anticipated_need_or_usage,
                                "unitPrice": item.estimated_price_per_training_unit,
                                "quantity": 1, // always 1 for ANNUAL_SUBSCRIPTION
                                "unit": "year", // always year for ANNUAL_SUBSCRIPTION
                            });
                        });
                    }
                    else if (item.training_unit === "MONTHLY_SUBSCRIPTION" || item.training_unit === "PER_PERSON" || item.training_unit === "PER_CLASS") {
                        if (item.training_option === "SINGLE") {
                            // map item.single to all values in the selected_periods
                            item.training_instance_info.selected_periods.forEach(function (period) {

                                // Map period_type and base_period of the periods_estimate array
                                var formattedPeriodOutput = periods_estimate.map(function (input) {
                                    return input.period.periodType + input.period.optionOrder;
                                });

                                var indexOfCurrentPeriod = formattedPeriodOutput.indexOf(period.periodType + period.optionOrder);

                                // Insert into periods_estimate, under the specified period and period_line_items 
                                periods_estimate[indexOfCurrentPeriod].periodLineItems.push({
                                    "idiqClin": Igce.prototype.determineIdiqClin(item.classification_info, "CLOUD_SUPPORT"),
                                    "contractType": "TBD",
                                    "dowTaskNumber": "TBD",
                                    "serviceTitle": item.training_instance_info.instance_name,
                                    "itemDescription": item.training_instance_info.anticipated_need_or_usage,
                                    "unitPrice": item.estimated_price_per_training_unit,
                                    "quantity": item.single, // 
                                    "unit": Igce.prototype.determineTrainingUnit(item.training_unit), // add function to format training unit
                                });
                            });
                        }
                        else if (item.training_option === "MULTIPLE") {
                            // map to only the values in the item.multiple array
                            item.multiple.forEach(function (period) {

                                // Map period_type and base_period of the periods_estimate array
                                var formattedPeriodOutput = periods_estimate.map(function (input) {
                                    return input.period.periodType + input.period.optionOrder;
                                });

                                var indexOfCurrentPeriod = formattedPeriodOutput.indexOf(period.periodType + period.optionOrder);

                                // Insert into periods_estimate, under the specified period and period_line_items 
                                periods_estimate[indexOfCurrentPeriod].periodLineItems.push({
                                    "idiqClin": Igce.prototype.determineIdiqClin(item.classification_info, "CLOUD_SUPPORT"),
                                    "contractType": "TBD",
                                    "dowTaskNumber": "TBD",
                                    "serviceTitle": item.training_instance_info.instance_name,
                                    "itemDescription": item.training_instance_info.anticipated_need_or_usage,
                                    "unitPrice": item.estimated_price_per_training_unit,
                                    "quantity": period.quantity, // 
                                    "unit": Igce.prototype.determineTrainingUnit(item.training_unit), // add function to format training unit
                                });
                            });
                        }
                    }

                }
                else if (item.training_instance_info.need_for_entire_task_order_duration) {
                    if (item.training_unit === "ANNUAL_SUBSCRIPTION") {
                        // map to each periods_estimate because its needed for entire to duration and annual
                        // unit is year, quantity is always 1 (melissa)
                        periods_estimate.forEach(function (period) {
                            period.periodLineItems.push({
                                "idiqClin": Igce.prototype.determineIdiqClin(item.classification_info, "CLOUD_SUPPORT"),
                                "contractType": "TBD",
                                "dowTaskNumber": "TBD",
                                "serviceTitle": item.training_instance_info.instance_name,
                                "itemDescription": item.training_instance_info.anticipated_need_or_usage,
                                "unitPrice": item.estimated_price_per_training_unit,
                                "quantity": 1, // always 1 for ANNUAL_SUBSCRIPTION
                                "unit": "year", // always year for ANNUAL_SUBSCRIPTION
                            });
                        });
                    }
                    else if (item.training_unit === "MONTHLY_SUBSCRIPTION" || item.training_unit === "PER_PERSON" || item.training_unit === "PER_CLASS") {
                        if (item.training_option === "SINGLE") {
                            // apply item.single value to each item in periods_estimate
                            periods_estimate.forEach(function (period) {
                                period.periodLineItems.push({
                                    "idiqClin": Igce.prototype.determineIdiqClin(item.classification_info, "CLOUD_SUPPORT"),
                                    "contractType": "TBD",
                                    "dowTaskNumber": "TBD",
                                    "serviceTitle": item.training_instance_info.instance_name,
                                    "itemDescription": item.training_instance_info.anticipated_need_or_usage,
                                    "unitPrice": item.estimated_price_per_training_unit,
                                    "quantity": item.single, // 
                                    "unit": Igce.prototype.determineTrainingUnit(item.training_unit),
                                });
                            });
                        }
                        else if (item.training_option === "MULTIPLE") {
                            // map to only the values in the item.multiple array
                            item.multiple.forEach(function (period) {

                                // Map period_type and base_period of the periods_estimate array
                                var formattedPeriodOutput = periods_estimate.map(function (input) {
                                    return input.period.periodType + input.period.optionOrder;
                                });

                                var indexOfCurrentPeriod = formattedPeriodOutput.indexOf(period.periodType + period.optionOrder);

                                // Insert into periods_estimate, under the specified period and period_line_items 
                                periods_estimate[indexOfCurrentPeriod].periodLineItems.push({
                                    "idiqClin": Igce.prototype.determineIdiqClin(item.classification_info, "CLOUD_SUPPORT"),
                                    "contractType": "TBD",
                                    "dowTaskNumber": "TBD",
                                    "serviceTitle": item.training_instance_info.instance_name,
                                    "itemDescription": item.training_instance_info.anticipated_need_or_usage,
                                    "unitPrice": item.estimated_price_per_training_unit,
                                    "quantity": period.quantity, // 
                                    "unit": Igce.prototype.determineTrainingUnit(item.training_unit),
                                });
                            });
                        }

                    }

                }
            });

        } catch (error) {
            throw this.errUtil.createError(
                "Igce --> mapTrainingToPeriodsEstimate(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },

    getTravelRequirements: function (packageSysId) {
        try {
            var packageId = packageSysId ? packageSysId : this.acquisitionPackage.sys_id;
            var limit = 50; // arbitrary
            return new global.GlideQuery(Igce.prototype.TRAVEL_REQ_TABLE)
                .where("acquisition_package", packageId)
                .select(Igce.prototype.TRAVEL_REQ_FIELDS)
                .toArray(limit);
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> getTravelRequirements(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },
    getTrainingEstimates: function (packageSysId) {
        try {
            var packageId = packageSysId ? packageSysId : this.acquisitionPackage.sys_id;
            var limit = 50; // arbitrary
            return new global.GlideQuery(Igce.prototype.TRAINING_ESTIMATE_TABLE)
                .where("acquisition_package", packageId)
                .select(Igce.prototype.TRAINING_ESTIMATE_FIELDS)
                .toArray(limit);
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> getTrainingEstimates(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },
    getIgceEstimates: function (packageSysId) {
        try {
            var packageId = packageSysId ? packageSysId : this.acquisitionPackage.sys_id;
            var limit = 50; // arbitrary
            return new global.GlideQuery(Igce.prototype.IGCE_ESTIMATE_TABLE)
                .where("acquisition_package", packageId)
                .select(Igce.prototype.IGCE_ESTIMATE_FIELDS)
                .toArray(limit);
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> getIgceEstimates(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },
    getIgceInstanceData: function (table, id) {
        try {
            var instance_data = new global.GlideQuery(table).get(id, Igce.prototype.SELECTED_PERIOD_FIELDS).orElse(null);
            var instance_data_with_periods = Igce.prototype.getInstancePeriodInfo(instance_data);
            return instance_data_with_periods;
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> getIgceInstanceData(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },
    getCloudSupportInstance: function (table, id) {
        try {
            var cloud_support_data = new global.GlideQuery(table).get(id, Igce.prototype.CLOUD_SUPPORT_ENV_INST_FIELDS).orElse(null);
            var cloud_support_data_with_periods = Igce.prototype.getInstancePeriodInfo(cloud_support_data);
            return cloud_support_data_with_periods;
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> getCloudSupportInstance(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },
    getClassificationLevel: function (classificationId) {
        try {
            var classification_level = new global.GlideQuery(Igce.prototype.CLASSIFICATION_LEVEL_TABLE).get(classificationId, ["classification"]).orElse(null);
            return classification_level.classification;
        } catch (error) {
            throw this.errUtil.createError(
                "Igce --> getClassificationLevel(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },
    determineIdiqClin: function (classification, idiq_clin_type) {
        if (classification === "U" && idiq_clin_type === "CLOUD") {
            return "x001/x017 Cloud UNCLASSIFIED"
        }
        if (classification === "U" && idiq_clin_type === "CLOUD_SUPPORT") {
            return "x002/x018 Cloud Support UNCLASSIFIED"
        }
        if (classification === "S" && idiq_clin_type === "CLOUD") {
            return "x003/x019 Cloud SECRET CLASSIFIED"
        }
        if (classification === "S" && idiq_clin_type === "CLOUD_SUPPORT") {
            return "x004/x020 Cloud Support SECRET CLASSIFIED"
        }
        if (classification === "TS" && idiq_clin_type === "CLOUD") {
            return "x005/x021 Cloud TOP SECRET CLASSIFIED"
        }
        if (classification === "TS" && idiq_clin_type === "CLOUD_SUPPORT") {
            return "x006/x022 Cloud Support TOP SECRET CLASSIFIED"
        }
    },

    // Get Igce Estimate Properties that are sys_id references
    getIgceProperties: function (igce) {
        try {
            // Set up IGCE object to parse through
            igce.forEach(function (item) {
                // Get classification level
                if (item.classification_level) {
                    item.classification_level = Igce.prototype.getClassificationLevel(item.classification_level)
                }
                // Get unit_quantity
                // This field is a stringified JSON, sys_id: quantity
                if (item.unit_quantity) {
                    item.quantity_info_periods = Igce.prototype.getSysIdValuePairs(item.unit_quantity);
                }
            });
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> getIgceProperties(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }

    },


    // Get IGCE Instructions
    getIgceInstructions: function (packageSysId) {
        try {
            var packageId = packageSysId ? packageSysId : this.acquisitionPackage.sys_id;
            var limit = 50; // arbitrary
            var igce_instructs = new global.GlideQuery(Igce.prototype.REQ_COST_ESTIMATE_TABLE)
                .where("acquisition_package", packageId)
                .select(Igce.prototype.REQ_COST_ESTIMATE_FIELDS)
                .toArray(limit);
            // This query is a bit bugged, should only need to return the object instead of an array of a single object,
            // however there is a bug with how GlideQuery handles display values not resulting in the sys_id not being found.
            // bandaid fix is returning the first object in the igce_instructs array
            if (igce_instructs.length != 0) {
                return igce_instructs[0];
            }
            return null;
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> getIgceInstructions(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }

    },
    // Used specifically to map quantity_info_periods to selected_periods
    mapTravelQuantity: function (igce) {
        try {
            igce.forEach(function (item) {
                item.quantity_info_periods.forEach(function (period_to_map) {
                    item.instance_info.selected_periods.forEach(function (period) {
                        if (period_to_map.periodType === period.periodType && period_to_map.periodUnitCount === period.periodUnitCount
                            && period_to_map.optionOrder === period.optionOrder && period_to_map.periodUnit === period.periodUnit) {
                            period.quantity = period_to_map.quantity;
                        }
                    });
                });
            });
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> mapQuantity(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },

    // Used specifically to map quantity_info_periods if SINGLE period is selected
    mapSingleQuantity: function (instance) {
        try {
            instance.forEach(function (item) {
                item.instance_info.selected_periods.forEach(function (period) {
                    {
                        period.quantity = item.quantity_info_periods;
                    }
                });

            });
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> mapQuantity(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },

    getPerPeriodValue: function (per_period_json_string) {
        var obj = new global.JSON().decode(per_period_json_string);
        var period_value;
        for (var key in obj) {
            period_value = obj[key];
        }
        return period_value;
    },

    // Takes sys_id: quantity json string objects and returns the correct period per sys_id
    getSysIdValuePairs: function (sys_id_json_string) {
        try {
            // attempt to decode string
            var quantity_arr = [];
            var obj = new global.JSON().decode(sys_id_json_string);
            for (var key in obj) {
                // For each sys_id, query the period table and retrieve the required period fields
                var quantity_data = new global.GlideQuery(Igce.prototype.PERIOD_TABLE).get(key, Igce.prototype.PERIOD_FIELDS).orElse(null);
                if (quantity_data) {
                    var formatted_option_order;
                    if (quantity_data.option_order == null) {
                        formatted_option_order = "";
                    }
                    else {
                        formatted_option_order = quantity_data.option_order.toString();
                    }
                    var quantity_period_info = {
                        "periodType": quantity_data.period_type.toString(),
                        "periodUnitCount": quantity_data.period_unit_count.toString(),
                        "periodUnit": quantity_data.period_unit.toString(),
                        "optionOrder": formatted_option_order,
                        "quantity": obj[key]
                    };
                    quantity_arr.push(quantity_period_info);
                }

            }
            return quantity_arr;
        }
        catch (error) {
            throw this.errUtil.createError(
                "Igce --> getSysIdValuePairs(): " + error,
                this.errUtil.METHOD_ERROR
            );
        }
    },

    getPayload: function () {
        var acq_package = this.acquisitionPackage;
        var periodOfPerformance = acq_package.period_of_performance;
        var fundingRequest = acq_package.funding_request;

        if (!periodOfPerformance) {
            throw this.errUtil.createError(
                "Igce --> Please provide a Period of Performance for package " + acq_package.number,
                this.errUtil.INVALID_INPUT
            );
        }

        // Get Periods for Period's Estimate
        var periodsEstimate = this.getPackagePeriods(
            periodOfPerformance.base_period, periodOfPerformance.option_periods
        );

        // Get Funding Request
        var fundingDocument;
        if (fundingRequest) {
            if (fundingRequest.funding_request_type == "MIPR") {
                fundingDocument = {
                    "fundingType": fundingRequest.funding_request_type.toString(),
                    "miprNumber": fundingRequest.mipr.mipr_number.toString()
                }
            }
            else if (fundingRequest.funding_request_type == "FS_FORM") {
                fundingDocument = {
                    "fundingType": fundingRequest.funding_request_type.toString(),
                    "gtcNumber": fundingRequest.fs_form.gt_c_number.toString(),
                    "orderNumber": fundingRequest.fs_form.order_number.toString()
                }
            }
        }

        // Get instructions
        var igceInstructions = this.getIgceInstructions(this.acquisitionPackage.sys_id);
        var igceSurgeCapabilities = null;
        var instructions = null;

        if (igceInstructions) {
            if (igceInstructions.surge_requirement_capabilities === "YES") {
                igceSurgeCapabilities = igceInstructions.surge_requirement_capacity;
            }
            var toolsUsed = "";
            if (igceInstructions.how_est_dev_tools_used) {
                toolsUsed += igceInstructions.how_est_dev_tools_used;
            }
            if (igceInstructions.how_est_dev_other_tools_used) {
                toolsUsed += " " + igceInstructions.how_est_dev_other_tools_used;
            }

            instructions = {
                estimateDescription: igceInstructions.how_est_dev_cost_estimate_description,
                assumptionsMade: "assumptions",
                toolsUsed: toolsUsed,
                informationSource: "info source",
                previousEstimateComparison: igceInstructions.how_est_dev_prev_cost_estimate_comp_option
            };
        }

        // Get Contracting Shop
        var cShop;
        if (acq_package.contracting_shop) {
            cShop = acq_package.contracting_shop.toString();
        }

        // Get Training Estimates
        var training_estimates = this.getTrainingEstimates(this.acquisitionPackage.sys_id);
        if (training_estimates.length != 0) {
            // For each Training Estimate
            training_estimates.forEach(function (training) {
                training.training_instance_info = Igce.prototype.getCloudSupportInstance(Igce.prototype.CLOUD_SUPPORT_ENV_INST_TABLE, training.cloud_support_environment_instance);
                training.classification_info = Igce.prototype.getClassificationLevel(training.training_instance_info.classification_level);

                // Check Training Unit, if it isn't ANNUAL_SUBSCRIPTION (training_option for that is always null)
                if (training.training_unit === "MONTHLY_SUBSCRIPTION" || training.training_unit === "PER_PERSON" || training.training_unit === "PER_CLASS") {
                    // Determine training_option
                    // I want to apply the same price estimate to all performance periods.
                    if (training.training_option === "SINGLE") {
                        // Look up Cloud Support Environment Instance
                        var per_period_value = Igce.prototype.getPerPeriodValue(training.training_estimated_values);
                        training.single = per_period_value;
                    }
                    else if (training.training_option === "MULTIPLE") {
                        var training_cost_per_period = Igce.prototype.getSysIdValuePairs(training.training_estimated_values);
                        training.multiple = training_cost_per_period;
                    }
                }
            });
            this.mapTrainingToPeriodsEstimate(training_estimates, periodsEstimate);
        }

        // Get all Travel Requirements
        var travel_reqs;

        if (igceInstructions.travel_option) {
            // If it is SINGLE, the same cost will be applied to each period
            var travel_costs_per_period;
            if (igceInstructions.travel_option === "SINGLE") {
                // PER_PERIOD JSON
                travel_costs_per_period = this.getPerPeriodValue(igceInstructions.travel_estimated_values);

            }
            else if (igceInstructions.travel_option === "MULTIPLE") {
                travel_costs_per_period = this.getSysIdValuePairs(igceInstructions.travel_estimated_values);
            }

            travel_reqs = this.getTravelRequirements(this.acquisitionPackage.sys_id);
            // Format travel_reqs to mimic igce estimate format so we can reuse existing period mapping
            travel_reqs.forEach(function (item) {
                var periods_to_retrieve = {
                    selected_periods: item.selected_periods,
                    need_for_entire_task_order_duration: false
                }
                var periods = Igce.prototype.getInstancePeriodInfo(periods_to_retrieve);
                item.instance_info = periods;
                item.quantity_info_periods = travel_costs_per_period;
                var travelDescription = "";
                travelDescription = item.number_of_trips + " x (" + item.trip_location + ", " + item.duration_in_days + " days, " + item.number_of_travelers + " travelers); ";
                item.travel_description = travelDescription;
            });

            if (igceInstructions.travel_option === "MULTIPLE") {
                this.mapTravelQuantity(travel_reqs);
            }
            else if (igceInstructions.travel_option === "SINGLE") {
                this.mapSingleQuantity(travel_reqs);
            }
            this.mapTravelToPeriodsEstimate(travel_reqs, periodsEstimate);
        }

        // Get all IGCE Estimates that have the acquisition package as the FK
        var igce = this.getIgceEstimates(this.acquisitionPackage.sys_id);
        // Determine selected_periods for instance_info and classification_level
        this.getIgceProperties(igce);
        // Map igce estimates to periods estimate
        this.mapIgceToPeriodsEstimate(igce, periodsEstimate);

        // IGCE generated-document payload

        var igce_payload = {
            documentType: "INDEPENDENT_GOVERNMENT_COST_ESTIMATE",
            templatePayload: {
                fundingDocument: fundingDocument,
                periodsEstimate: periodsEstimate,
                contractingShop: cShop,
                instructions: instructions,
                surgeCapabilities: igceSurgeCapabilities,
            }
        };

        // Format the final payload
        return JSON.stringify(igce_payload);
    }
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>jeff.segal-ctr</sys_created_by>
        <sys_created_on>2022-10-12 15:53:33</sys_created_on>
        <sys_id>b29002b097a211106fa8b4b3f153afc4</sys_id>
        <sys_mod_count>77</sys_mod_count>
        <sys_name>Igce</sys_name>
        <sys_package display_value="ATAT" source="x_g_dis_atat">f600233d1b154d507b782f84604bcb12</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="ATAT">f600233d1b154d507b782f84604bcb12</sys_scope>
        <sys_update_name>sys_script_include_b29002b097a211106fa8b4b3f153afc4</sys_update_name>
        <sys_updated_by>zach.clark</sys_updated_by>
        <sys_updated_on>2023-02-05 22:47:28</sys_updated_on>
    </sys_script_include>
</record_update>
