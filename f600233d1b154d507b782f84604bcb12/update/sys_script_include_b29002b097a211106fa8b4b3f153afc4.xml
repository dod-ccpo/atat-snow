<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_g_dis_atat.Igce</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>Igce</name>
        <script><![CDATA[var Igce = Class.create();
Igce.prototype = {

    acquisitionPackage: null,

    initialize: function (acquisitionPackage) {
        this.acquisitionPackage = acquisitionPackage;
    },

    getEstimatedObligation: function (filterFn) {
        return this.getPayload().templatePayload.periodsEstimate.map(function (estimate) {
            return estimate.periodLineItems;
        }).reduce(function (pre, cur) {
            return pre.concat(cur);
        }).reduce(function (result, item) {
            return result + (item.monthlyPrice * item.monthsInPeriod);
        }, 0);
    },

    getEstimatedBaseYearObligation: function () {
        return this.getPayload().templatePayload.periodsEstimate.filter(function (estimate) {
            return estimate.period.periodType == "BASE";
        }).map(function (estimate) {
            return estimate.periodLineItems;
        }).reduce(function (pre, cur) {
            return pre.concat(cur);
        }).reduce(function (result, item) {
            return result + (item.monthlyPrice * item.monthsInPeriod);
        }, 0);
    },

    getPackagePeriods: function (base, options) {
        // This returns the periods in the IGCE schema for the Periods Estimate Object
        var mappedPeriods = [];
        if (base) {
            mappedPeriods.push({
                "period": {
                    "periodType": base.period_type.toString(),
                    "periodUnitCount": base.period_unit_count.toString(),
                    "periodUnit": base.period_unit.toString(),
                    "optionOrder": base.option_order.toString()
                },
                "periodLineItems": [],
            });
        }
        if (options) {
            getListRecords(options,
                ["period_type", "period_unit_count", "period_unit", "option_order"],
                "x_g_dis_atat_period")
                .forEach(function (period) {
                    mappedPeriods.push({
                        "period": {
                            "periodType": period.period_type.toString(),
                            "periodUnitCount": period.period_unit_count.toString(),
                            "periodUnit": period.period_unit.toString(),
                            "optionOrder": period.option_order.toString()
                        }, "periodLineItems": []
                    });
                });
        }
        return mappedPeriods;
    },

    getInstanceInfo: function (instance) {
        //This function retrieves:
        // classification_level
        // selected_periods
        // need_for_entire_task_order_duration
        // Appending it to the given Classification Instance, Environment Instance, Estimated Environment Instance

        var selectedPeriodsFields = ["period_type", "option_order", "period_unit", "period_unit_count"];

        var entireDuration = convertToBoolean(instance.need_for_entire_task_order_duration.toString());
        instance.need_for_entire_task_order_duration = entireDuration;

        if (entireDuration) {
            instance.selected_periods = [];
        } else {
            var selectedPeriods = [];
            var retrieved_periods = getListRecords(instance.selected_periods.toString(), selectedPeriodsFields, "x_g_dis_atat_period").map(removeSysId);
            for (var i = 0; i < retrieved_periods.length; i++) {
                var formatted_option_order;
                if (retrieved_periods[i].option_order == null) {
                    formatted_option_order = "";
                }
                else {
                    formatted_option_order = retrieved_periods[i].option_order.toString();
                }
                selectedPeriods.push({
                    "periodType": retrieved_periods[i].period_type.toString(),
                    "periodUnitCount": retrieved_periods[i].period_unit_count.toString(),
                    "periodUnit": retrieved_periods[i].period_unit.toString(),
                    "optionOrder": formatted_option_order
                });
            };
            instance.selected_periods = selectedPeriods;
        }

        var classLevel = new global.GlideQuery("x_g_dis_atat_classification_level")
            .get(instance.classification_level.toString(),
                ["impact_level", "classification"])
            .orElse(null);

        classLevel = removeSysId(classLevel);
        instance.classification_level = classLevel;
        return instance;
    },

    getNestedIgceServiceInfo: function (selectedService) {
        // Get Service Offering or user created offering for each selection
        var offering;
        if (selectedService.service_offering) {
            offering = new global.GlideQuery("x_g_dis_atat_service_offering")
                .get(selectedService.service_offering,
                    ["service_offering_group", "name"])
                .orElse(null);
            offering = removeSysId(offering);
        } else {
            offering = {
                name: selectedService.other_service_offering.toString(),
                service_offering_group: null
            };
        }
        selectedService.service_offering = offering;

        // Get Classification Instances info
        if (selectedService.classification_instances) {
            var classificationInstanceFields = [
                "need_for_entire_task_order_duration", "usage_description",
                "classification_level", "selected_periods", "monthly_price", "dow_task_number"];
            selectedService.classification_instances = getListRecords(
                selectedService.classification_instances.toString(),
                classificationInstanceFields,
                "x_g_dis_atat_classification_instance").map(removeSysId).map(Igce.prototype.getInstanceInfo);

        }

        // Get Estimated Environment Instances
        if (selectedService.estimated_environment_instances) {
            var estimatedEnvironmentInstanceFields = [
                "need_for_entire_task_order_duration", "classification_level", "selected_periods", "monthly_price",
                "dow_task_number", "instance_name", "instance_location", "number_of_vcpus", "storage_amount",
                "storage_type", "memory_amount", "memory_unit", "data_egress_monthly_amount", "data_egress_monthly_unit"
            ];
            selectedService.estimated_environment_instances = getListRecords(
                selectedService.estimated_environment_instances.toString(),
                estimatedEnvironmentInstanceFields,
                "x_g_dis_atat_estimated_environment_instance").map(removeSysId).map(Igce.prototype.getInstanceInfo);
        }
        return selectedService;
    },
    getSelectedServiceOfferings: function (selectedServiceOfferings) {
        // Retrieve selected service offerings, classification instances, and estimated environment instances 
        var selectedServiceFields = [
            "other_service_offering", "service_offering",
            "classification_instances", "estimated_environment_instances"
        ];

        var selected_service_offerings = getListRecords(
            selectedServiceOfferings.toString(),
            selectedServiceFields,
            "x_g_dis_atat_selected_service_offering")
            .map(removeSysId)
            .map(this.getNestedIgceServiceInfo);

        return selected_service_offerings;
    },
    getCurrentEnvironment: function (currentEnvironment) {
        // Retrieve Environment Instance Fields
        var environmentInstanceFields = [
            "need_for_entire_task_order_duration", "instance_name",
            "classification_level", "selected_periods"];
        var env = new GlideRecord("x_g_dis_atat_current_environment");
        env.get(currentEnvironment.toString());

        var current_environment = getListRecords(
            env.environment_instances.toString(),
            environmentInstanceFields,
            "x_g_dis_atat_environment_instance").map(removeSysId).map(Igce.prototype.getInstanceInfo);
        return current_environment;
    },

    mapEnvironmentInstance: function (data_to_map, periods_estimate, formatted_idiq_clins, is_current_env, service_offering) {
        // This works for Environment Instance or Estimated Environment Instance
        // For each Environment Instance in the data_to_map array
        data_to_map.forEach(function (item) {
            // Create environment configuration summary
            var configSummary = item.instance_location + " " + item.number_of_vcpus + " vCPU(s) "
                + item.storage_amount + " " + item.storage_type + " Storage "
                + item.memory_amount + " " + item.memory_unit + " Memory"
                + item.data_egress_monthly_unit + " " + item.data_egress_monthly_amount + " Data Egress."


            var serviceOffering, monthlyPrice, dowTaskNumber;
            // If its the current environment...
            if (is_current_env) {
                dowTaskNumber = "4.1.1";
                monthlyPrice = "N/A";
                serviceOffering = "Current Environment - " + item.instance_name;

            }
            else {
                dowTaskNumber = item.dow_task_number;
                serviceOffering = service_offering;
                monthlyPrice = item.monthly_price;
            }

            // If the Environment Instance is NOT needed for the entire TO duration
            // Map it to the periods specified in period_line_items
            if (!item.need_for_entire_task_order_duration) {

                // For each period in the selected_periods array of the estimated environment instance
                item.selected_periods.forEach(function (period) {

                    // Map period_type and base_period of the periods_estimate array
                    var formattedPeriodOutput = periods_estimate.map(function (input) {
                        return input.period.periodType + input.period.optionOrder;
                    });


                    var indexOfCurrentPeriod = formattedPeriodOutput.indexOf(period.periodType + period.optionOrder);


                    // Insert into periods_estimate, under the specified period and period_line_items /////////////////////Fix this output
                    periods_estimate[indexOfCurrentPeriod].periodLineItems.push({
                        "clin": "1000",
                        "idiqClin": getClinFromDowTask(item.dow_task_number, formatted_idiq_clins),
                        "dowTaskNumber": dowTaskNumber,
                        "serviceOffering": serviceOffering,
                        "itemDescriptionOrConfigSummary": configSummary,
                        "monthlyPrice": monthlyPrice,
                        "monthsInPeriod": monthsInPeriod(period.periodUnit, period.periodUnitCount),
                    });
                });
            }
            // Else if the Current Environment is needed for the entire TO duration
            // Map it to each period in the periods_estimate array
            else if (item.need_for_entire_task_order_duration) {
                periods_estimate.forEach(function (period) {
                    period.periodLineItems.push({
                        "clin": "x001",
                        "idiqClin": getClinFromDowTask(item.dow_task_number, formatted_idiq_clins),
                        "dowTaskNumber": dowTaskNumber,
                        "serviceOffering": serviceOffering,
                        "itemDescriptionOrConfigSummary": configSummary,
                        "monthlyPrice": monthlyPrice,
                        "monthsInPeriod": monthsInPeriod(period.period.periodUnit, period.period.periodUnitCount),
                    });
                });
            }
        });
    },
    mapClassificationInstance: function (data_to_map, periods_estimate, formatted_idiq_clins, service_offering) {
        data_to_map.forEach(function (instance) { ////FOR EACH CLASSIFICATION INSTANCE
            // Check if need for entire task order duration is false
            // If false, use the selected_periods array of the classification instance
            if (!instance.need_for_entire_task_order_duration) {
                // For each period in the selected_periods array of the classification instance
                instance.selected_periods.forEach(function (period) {
                    // Map period_type and base_period of the periods_estimate array
                    var formattedPeriodOutput = periods_estimate.map(function (input) {
                        return input.period.periodType + input.period.optionOrder;
                    });
                    var indexOfCurrentPeriod = formattedPeriodOutput.indexOf(period.periodType + period.optionOrder);
                    // Insert into periods_estimate, under the specified period and period_line_items
                    periods_estimate[indexOfCurrentPeriod].periodLineItems.push({
                        "clin": "x001",
                        "idiqClin": getClinFromDowTask(instance.dow_task_number, formatted_idiq_clins),
                        "dowTaskNumber": instance.dow_task_number,
                        "serviceOffering": service_offering.name,
                        "itemDescriptionOrConfigSummary": instance.usage_description,
                        "monthlyPrice": instance.monthly_price,
                        "monthsInPeriod": monthsInPeriod(period.periodUnit, period.periodUnitCount),

                    });
                });
            }
            // If instance is needed for the entire task_order_duration, add it to all period_line_items
            else if (instance.need_for_entire_task_order_duration) {
                periods_estimate.forEach(function (period) {
                    period.periodLineItems.push({
                        "clin": "x001",
                        "idiqClin": getClinFromDowTask(instance.dow_task_number, formatted_idiq_clins),
                        "dowTaskNumber": instance.dow_task_number,
                        "serviceOffering": service_offering.name,
                        "itemDescriptionOrConfigSummary": instance.usage_description,
                        "monthlyPrice": instance.monthly_price,
                        "monthsInPeriod": monthsInPeriod(period.period.periodUnit, period.period.periodUnitCount),
                    });
                });
            }
        });
    },
    getClinInfo: function (idiqClins) {
        var idiqFields = ["contract", "idiq_clin", "description", "contract_type", "classification_level"];
        //put everything into an array
        var clin_info = getListRecords(idiqClins.toString(), idiqFields, 'x_g_dis_atat_idiq_clin').map(removeSysId);
        clin_info.forEach(function (item) {
            if (item.classification_level != null) {
                var gr = new GlideRecord('x_g_dis_atat_classification_level');
                gr.get(item.classification_level.toString());
                var classLevel = gr.getDisplayValue('classification');
                item.classification_level = classLevel.toUpperCase();
                // IGCE appends a CLASSFIED to the end of SECRET and TOP SECRET, format string to reflect that difference
                if (item.classification_level == "SECRET" || item.classification_level == "TOP SECRET") {
                    item.classification_level += " CLASSIFIED";
                }

            }
        });

        var formatted_clin_info = [];
        clin_info.forEach(function (item1) {
            clin_info.forEach(function (item2) {
                var idiqClinString;
                // If the items descriptions and classification_levels match, create a new idiqClinString
                if (item1.description == item2.description && item1.classification_level == item2.classification_level && item1.idiq_clin != item2.idiq_clin) {
                    // Lowest IDIQ CLIN first
                    if (parseInt(item1.idiq_clin) < parseInt(item2.idiq_clin)) {
                        idiqClinString = "x" + item1.idiq_clin.substr(1) + "/x" + item2.idiq_clin.substr(1) + " " + item1.description + " " + item1.classification_level;
                    }
                    else {
                        idiqClinString = "x" + item2.idiq_clin.substr(1) + "/x" + item1.idiq_clin.substr(1) + " " + item1.description + " " + item1.classification_level;
                    }
                    // If it doesn't exist in the array of new CLINs, push it
                    if (formatted_clin_info.indexOf(idiqClinString) == -1) {
                        formatted_clin_info.push(idiqClinString);
                    }
                }
                // If the description is Travel or External Agency Fee, this is a one-off IDIQ CLIN
                else if (item1.description == "Travel" || item1.description == "External Ordering Agency Fee") {
                    idiqClinString = "x" + item1.idiq_clin.substr(1) + " " + item1.description + " " + item1.contract_type;
                    if (formatted_clin_info.indexOf(idiqClinString) == -1) {
                        formatted_clin_info.push(idiqClinString);
                    }
                }
            });
        });
        return formatted_clin_info;
    },
    getPayload: function () {
        var acq_package = this.acquisitionPackage;
        var periodOfPerformance = acq_package.period_of_performance;
        var currentEnvironment = acq_package.current_environment;
        var selectedServiceOfferings = acq_package.selected_service_offerings;
        var idiqClins = acq_package.idiq_clins;
        var fundingRequest = acq_package.funding_request;
        var requirementsCostEstimate = acq_package.requirements_cost_estimate;


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // TODO: 
        // In order to prevent SNOW Error: Cannot convert null to an object.,Detail: Cannot convert null to an object.
        // Check for missing fields, return an error if they don"t exist
        if (!periodOfPerformance) {
            // return an error
            return {
                error: "Missing Period of Performance"
            };
        }

        if (!selectedServiceOfferings && !currentEnvironment) {
            // return an error
            return {
                error: "Selected Service Offerings OR Current Environment are required to generate IGCE"
            };
        }


        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // Get Formatted CLINs
        var formattedIdiqClins = Igce.prototype.getClinInfo(idiqClins);

        // Get Periods for Period's Estimate
        var periodsEstimate = this.getPackagePeriods(
            periodOfPerformance.base_period, periodOfPerformance.option_periods
        );

        // If Current Environment Exists...
        if (currentEnvironment) {
            //map info to periodsEstimate
            var currentEnv = this.getCurrentEnvironment(currentEnvironment);
            var isCurrentEnv = true;
            Igce.prototype.mapEnvironmentInstance(currentEnv, periodsEstimate, formattedIdiqClins, isCurrentEnv);
        }

        // If Selected Service Offerings Exists (reference lists)
        if (selectedServiceOfferings) {
            //Map info to periodsEstimate
            var serviceOfferings = this.getSelectedServiceOfferings(selectedServiceOfferings);
            serviceOfferings.forEach(function (item) {
                if (item.classification_instances) {
                    var classificationInstances = item.classification_instances;
                    Igce.prototype.mapClassificationInstance(classificationInstances, periodsEstimate, formattedIdiqClins, item.service_offering);
                }
                else if (item.estimated_environment_instances) {
                    Igce.prototype.mapEnvironmentInstance(item, periodsEstimate, formattedIdiqClins, isCurrentEnv, item.service_offering);
                }
            });
        }

        // Get Funding Request
        var fundingDocument;
        if (fundingRequest) {
            if (fundingRequest.funding_request_type == "MIPR") {
                fundingDocument = {
                    "fundingType": fundingRequest.funding_request_type.toString(),
                    "miprNumber": fundingRequest.mipr.mipr_number.toString()
                }
            }
            else if (fundingRequest.funding_request_type == "FS_FORM") {
                fundingDocument = {
                    "fundingType": fundingRequest.funding_request_type.toString(),
                    "gtcNumber": fundingRequest.fs_form.gt_c_number.toString(),
                    "orderNumber": fundingRequest.fs_form.order_number.toString()
                }
            }
        }

        // Get Surge Capabilities
        var surgeCapabilities
        if (requirementsCostEstimate) {
            var gr = new GlideRecord('x_g_dis_atat_requirements_cost_estimate');
            gr.get(requirementsCostEstimate);
            surgeCapabilities = parseInt(gr.surge_capabilities.toString());
        }

        // IGCE generated-document payload
        var igce_payload = {
            documentType: "INDEPENDENT_GOVERNMENT_COST_ESTIMATE",
            templatePayload: {
                fundingDocument: fundingDocument,
                surgeCapabilities: surgeCapabilities,
                periodsEstimate: periodsEstimate,
            }
        };
        // Format the final payload
        return igce_payload;
    }
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>jeff.segal-ctr</sys_created_by>
        <sys_created_on>2022-10-12 15:53:33</sys_created_on>
        <sys_id>b29002b097a211106fa8b4b3f153afc4</sys_id>
        <sys_mod_count>16</sys_mod_count>
        <sys_name>Igce</sys_name>
        <sys_package display_value="ATAT" source="x_g_dis_atat">f600233d1b154d507b782f84604bcb12</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="ATAT">f600233d1b154d507b782f84604bcb12</sys_scope>
        <sys_update_name>sys_script_include_b29002b097a211106fa8b4b3f153afc4</sys_update_name>
        <sys_updated_by>1370228783.CTR</sys_updated_by>
        <sys_updated_on>2022-11-11 16:20:27</sys_updated_on>
    </sys_script_include>
</record_update>
